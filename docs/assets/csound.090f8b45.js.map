{"version":3,"mappings":"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","names":["csd","presetsOrc","csoundLoader","_csound","Pattern","instrument","init","time","hap","logger","gain","freq","getFrequency","controls","msg","getAudioContext","csound","code","a","pat","eventLogger","type","args","logType","load","__vitePreload","Csound","k","orcCache","loadOrc","url","_","path","res","pfields","tidal_time","audio_context_time","p1","p2","p3","frequency","p4","p5","_b","i_statement"],"sources":["../../packages/csound/project.csd?raw","../../packages/csound/presets.orc?raw","../../packages/csound/csound.mjs"],"sourcesContent":["export default \"<CsoundSynthesizer>\\n<CsInstruments>\\n\\nsr=48000\\nksmps=64\\nnchnls=2\\n0dbfs=1\\n\\n</CsInstruments>\\n</CsoundSynthesizer>\"","export default \"; returns value of given key in given \\\"string map\\\"\\n; keymap(\\\"freq\\\", \\\"note/c3/freq/220/gain/0.5\\\")\\n; yields \\\"220\\\"\\nopcode keymap, S, SS\\n  Skey, Smap xin\\n  idelimiter = strindex(Smap, strcat(Skey, \\\"/\\\"))\\n  ifrom = idelimiter + strlen(Skey) + 1\\n  Svalue = strsub(Smap, ifrom, strlen(Smap))\\n  Svalue = strsub(Svalue, 0, strindex(Svalue, \\\"/\\\"))\\n  xout Svalue\\nendop\\n\\n; TODO add incredibly dope synths\\ninstr organ\\n    iduration = p3\\n    ifreq = p4\\n    igain = p5\\n    ioct = octcps(ifreq)\\n\\n    asig = vco2(igain, ifreq, 12, .5) ; my edit\\n    kpwm = oscili(.1, 5)\\n    asig = vco2(igain, ifreq, 4, .5 + kpwm)\\n    asig += vco2(igain/4, ifreq * 2)\\n\\n    ; filter\\n    ; idepth = 2\\n    ; acut = transegr:a(0, .005, 0, idepth, .06, -4.2, 0.001, .01, -4.2, 0) ; filter envelope\\n    ; asig = zdf_2pole(asig, cpsoct(ioct + acut), 0.5)\\n\\n    ; amp envelope\\n    iattack = .001\\n    irelease = .05\\n    asig *= linsegr:a(0, iattack, 1, iduration, 1, irelease, 0)\\n\\n    out(asig, asig)\\n\\nendin\\n\\ninstr triangle\\n  iduration = p3\\n  ifreq = p4\\n  igain = p5\\n  ioct = octcps(ifreq)\\n  \\n  asig = vco2(igain, ifreq, 12, .5)\\n  \\n  ; amp envelope\\n  iattack = .001\\n  irelease = .05\\n  asig *= linsegr:a(0, iattack, 1, iduration, 1, irelease, 0)\\n  \\n  out(asig, asig)\\nendin\\n\\ninstr pad\\n    iduration = p3\\n    ifreq = p4\\n    igain = p5\\n    ioct = octcps(ifreq)\\n\\n    asig = vco2(igain, ifreq, 0)\\n\\n    ; amp envelope\\n    iattack = .5\\n    irelease = .1\\n    asig *= linsegr:a(0, iattack, 1, iduration, 1, irelease, 0)\\n    \\n    idepth = 2\\n    acut = transegr:a(0, .005, 0, idepth, .06, -4.2, 0.001, .01, -4.2, 0)\\n    asig = zdf_2pole(asig, 1000, 2)\\n\\n    out(asig, asig)\\nendin\\n\\n\\ngisine\\tftgen\\t0, 0, 4096, 10, 1\\n\\ninstr bow\\n    kpres = 2\\n    krat = 0.16\\n    kvibf = 6.12723\\n    \\n    kvib  linseg 0, 0.5, 0, 1, 1, p3-0.5, 1\\t\\n    kvamp = kvib * 0.01\\n    asig  wgbow .7, p4, kpres, krat, kvibf, kvamp, gisine\\n    asig = asig*p5\\n    outs asig, asig\\nendin\\n\\n\\ninstr Meta\\n    Smap = strget(p6)\\n    Sinstrument = keymap(\\\"s\\\", Smap)\\n    schedule(Sinstrument, 0, p3, p4, p5)\\n    ; TODO find a way to pipe Sinstrument through effects\\nendin\"","import { getFrequency, logger, Pattern } from '@strudel.cycles/core';\n///import { Pattern, isPattern, isNote, toMidi, getPlayableNoteValue, logger } from '@strudel.cycles/core';\n\nimport { getAudioContext } from '@strudel.cycles/webaudio';\nimport csd from './project.csd?raw';\n// import livecodeOrc from './livecode.orc?raw';\nimport presetsOrc from './presets.orc?raw';\n\nlet csoundLoader, _csound;\n\n// triggers given instrument name using csound.\nPattern.prototype._csound = function (instrument) {\n  instrument = instrument || 'triangle';\n  init(); // not async to support csound inside other patterns + to be able to call pattern methods after it\n  // TODO: find a alternative way to wait for csound to load (to wait with first time playback)\n  return this.onTrigger((time, hap) => {\n    if (!_csound) {\n      logger('[csound] not loaded yet', 'warning');\n      return;\n    }\n    if (typeof hap.value !== 'object') {\n      throw new Error('csound only support objects as hap values');\n    }\n    let { gain = 0.8 } = hap.value;\n    gain *= 0.2;\n\n    const freq = Math.round(getFrequency(hap));\n    const controls = Object.entries({ ...hap.value, freq })\n      .flat()\n      .join('/');\n    // TODO: find out how to send a precise ctx based time\n    // http://www.csounds.com/manual/html/i.html\n    const params = [\n      `\"${instrument}\"`, // p1: instrument name\n      time - getAudioContext().currentTime, //.toFixed(precision), // p2: starting time in arbitrary unit called beats\n      hap.duration + 0, // p3: duration in beats\n      // instrument specific params:\n      freq, //.toFixed(precision), // p4: frequency\n      gain, // p5: gain\n      `\"${controls}\"`, // p6 controls as string (like superdirt osc message)\n    ];\n    const msg = `i ${params.join(' ')}`;\n    _csound.inputMessage(msg);\n  });\n};\n\n// initializes csound + can be used to reevaluate given instrument code\nexport async function csound(code = '') {\n  await init();\n  if (code) {\n    code = `${code}`;\n    //     ^       ^\n    // wrapping in backticks makes sure it works when calling as templated function\n    await _csound?.evalCode(code);\n  }\n}\n\nPattern.prototype.define('csound', (a, pat) => pat.csound(a), { composable: false, patternified: true });\n\nfunction eventLogger(type, args) {\n  const [msg] = args;\n  if (\n    type === 'message' &&\n    (['[commit: HEAD]'].includes(msg) ||\n      msg.startsWith('--Csound version') ||\n      msg.startsWith('libsndfile') ||\n      msg.startsWith('sr =') ||\n      msg.startsWith('0dBFS') ||\n      msg.startsWith('audio buffered') ||\n      msg.startsWith('writing') ||\n      msg.startsWith('SECTION 1:'))\n  ) {\n    // ignore\n    return;\n  }\n  let logType = 'info';\n  if (msg.startsWith('error:')) {\n    logType = 'error';\n  }\n  logger(`[csound] ${msg || ''}`, logType);\n}\n\nasync function load() {\n  if (window.__csound__) {\n    // allows using some other csound instance\n    logger('[load] Using external Csound', 'warning');\n    _csound = window.__csound__;\n  } else {\n    const { Csound } = await import('@csound/browser');\n    _csound = await Csound({ audioContext: getAudioContext() });\n    _csound.removeAllListeners('message');\n    ['message'].forEach((k) => _csound.on(k, (...args) => eventLogger(k, args)));\n    await _csound.setOption('-m0d'); // see -m flag https://csound.com/docs/manual/CommandFlags.html\n    await _csound.setOption('--sample-accurate');\n    await _csound.compileCsdText(csd);\n    // await _csound.compileOrc(livecodeOrc);\n    await _csound.compileOrc(presetsOrc);\n    await _csound.start();\n  }\n  return _csound;\n}\n\nasync function init() {\n  csoundLoader = csoundLoader || load();\n  return csoundLoader;\n}\n\nlet orcCache = {};\nexport async function loadOrc(url) {\n  await init();\n  if (typeof url !== 'string') {\n    throw new Error('loadOrc: expected url string');\n  }\n  if (url.startsWith('github:')) {\n    const [_, path] = url.split('github:');\n    url = `https://raw.githubusercontent.com/${path}`;\n  }\n  if (!orcCache[url]) {\n    orcCache[url] = fetch(url)\n      .then((res) => res.text())\n      .then((code) => _csound.compileOrc(code));\n  }\n  await orcCache[url];\n}\n\n/**\n * Sends notes to Csound for rendering, with MIDI semantics. The hap value is \n * translated to the following Csound pfields:\n *\n *  p1 -- Csound instrument number, 1-based, can be a fraction.\n *  p2 -- time in beats (usually seconds) from the start of this performance.\n *  p3 -- duration in beats (usually seconds).\n *  p4 -- MIDI key number (as a real number, not an integer, but in [0, 127].\n *  p5 -- MIDI velocity (as a real number, not an integer, but in [0, 127].\n */\nPattern.prototype._csoundm = function(...pfields) {\n  init();\n  return this.onTrigger((tidal_time, hap, audio_context_time) => {\n    if (!_csound) {\n      logger('[csoundm] Csound is not yet loaded', 'warning');\n      return;\n    }\n    if (typeof hap.value !== 'object') {\n      throw new Error('csoundm only supports objects as hap values');\n    }\n    const p1 = pfields[0];\n    // Time in seconds counting from now.\n    const p2 = tidal_time - audio_context_time;\n    const p3 = hap.duration.valueOf();\n    const frequency = getFrequency(hap);\n    // We translate frequency to MIDI key number _without_ rounding. \n    const C4 = 261.62558;\n    let octave = Math.log(frequency / C4) / Math.log(2.0) + 8.0;\n    const p4 = octave * 12.0 - 36.0;\n    // We prefer floating point precision, but over the MIDI range [0, 127].\n    const p5 = 127. * (hap.context?.velocity ?? 0.9);\n    // Build the Csound score event.\n    let i_statement = `i ${p1} ${p2} ${p3} ${p4} ${p5} \\n`;\n    logger(`[csoundm] ${i_statement}`);\n    if (_csound) {\n      _csound.inputMessage(i_statement);\n    } else {\n      logger('[csoundm] Csound is not defined!', warning);\n    }\n  });\n};\n\nPattern.prototype.define('csoundm', (a, pat) => pat.csoundm(a), { composable: false, patternified: true });\n\n\n\n\n"],"file":"assets/csound.090f8b45.js"}