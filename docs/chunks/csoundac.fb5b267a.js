import{l as o,k as u,N as w}from"./prebake.487e17f6.js";import"./voicings.375d8047.js";import"./index.a0884559.js";let d,a=!1;function y(e){a=e}function V(e){return(Math.log(e/261.62558)/Math.log(2)+8)*12-36}function $(e){let n=V(e);return Math.round(n)}function m(){d||globalThis.__csoundac__&&(d=globalThis.__csoundac__,o(`[csacLoad]: using global ${d}`,"information"))}function h(e,n){n.resize(e.voices());for(let t=0;t<e.voices();++t){let i=e.getPitch(t);n.getPitch(t),n.setPitch(t,i)}}function p(e){m(),a&&o("[csacChord] Creating Chord...","debug");let n=d.chordForName(e);return a&&o(`[csacChord] ${n.toString()}`,"debug"),n}const T=u("chordT",(e,n,t)=>t.withHap(i=>{let r=e.T(n);if(a){let l=`[chordT]: ${e.toString()} ${e.eOP().name()} T(${n}) =>
[chordT]: ${r.toString()} ${r.name()}`;o(l,"debug")}return h(r,e),i.withValue(()=>i.value)})),b=u("chordI",(e,n,t)=>t.withHap(i=>{let r=e.I(n);if(a){let l=`[chordI]: ${e.toString()} ${e.eOP().name()} I(${n}) =>
[chordI]: ${r.toString()} ${r.eOP().name()}`;o(l,"debug")}return h(r,e),i.withValue(()=>i.value)})),N=u("chordK",(e,n)=>n.withHap(t=>{let i=e.K();if(a){let r=`[chordK]: ${e.toString()} ${e.eOP().name()} K =>
[ChordK]: ${i.toString()} ${i.eOP().name()}`;o(r,"debug")}return h(i,e),t.withValue(()=>t.value)})),I=u("chordQ",(e,n,t,i)=>i.withHap(r=>{let l=e.Q(t,n,1);if(a){let c=`[chordQ]: ${e.toString()} ${e.eOP().name()} Q(${t}) =>
[chordQ]: ${l.toString()} ${l.eOP().name()}`;o(c,"debug")}return h(l,e),r.withValue(()=>r.value)})),H=u("chordNV",(e,n)=>n.withHap(t=>{let i;try{i=w(t)}catch{o("[chordNV] not a note!","warning");return}let r=$(i),l=d.closestPitch(r,e),c=t.withValue(()=>l);return a&&o(`[chordNV]: ${e.toString()} ${e.eOP().name()} old note: ${r} new note: ${c.value}`,"debug"),c})),k=u("chordN",(e,n)=>n.withHap(t=>{let i;try{i=w(t)}catch{o("[chordN] not a note!","warning");return}let r=$(i),l=d.conformToPitchClassSet(r,e.epcs()),c=t.withValue(()=>l);return a&&o(`[chordN]: ${e.toString()} ${e.eOP().name()} old note: ${r} new note: ${c.value}`,"debug"),c}));function C(e){m(),a&&o("[csacScale] Creating Scale...","debug");let n=d.scaleForName(e);return a&&o(`[csacScale] ${n.name()}`,"debug"),n}const M=u("scaleS",(e,n,t,i)=>i.withHap(r=>(new_chord=n.chord_(t,e.voices()),a&&o(`[scaleS]: old chord: ${e.toString()} scale step: ${t} new chord: ${new_chord.toString()}`,"debug"),h(new_chord,e),r.withValue(()=>r.value)))),O=u("scaleT",(e,n,t,i)=>i.withHap(r=>{let l=e.transpose_degrees(n,t,3);return a&&o(`[scaleT]: old chord: ${n.toString()} scale steps: ${t} new chord: ${l.toString()}`,"debug"),h(l,n),r.withValue(()=>r.value)})),q=u("scaleM",(e,n,t,i)=>i.withHap(r=>{let l=n.eOP(),c=e.modulations(l),s=e,g=c.size(),f=-1;if(g>0){if(f=t%g,s=c.get(f),a){let v=`
[scaleM]: modulating in: ${e.toString()} ${e.name()} 
[scaleM]: from pivot:    ${l.toString()} ${l.name()}
[scaleM]: modulations:   ${g} => ${f}
[scaleM]: modulated to:  ${s.toString()} ${s.name()}
`;o(v,"debug")}h(s,e)}return r.withValue(()=>r.value)})),K=u("scaleN",(e,n)=>n.withHap(t=>{let i;try{i=w(t)}catch{o("[scaleN] not a note!","warning");return}let r=$(i),l=d.conformToPitchClassSet(r,e),c=t.withValue(()=>l);return a&&o(`[scaleN]: old note: ${r} new note: ${l}`,"debug"),c}));function Q(e,n){a&&o("[csacPitv] Creating PITV group...","debug"),m();let t=new d.PITV;return t.initialize(e,n,1,!1),t.P=0,t.I=0,t.T=0,t.V=0,t.list(!0,!1,!1),t}const z=u("pitvP",(e,n,t)=>t.withHap(i=>(e.P=n,a&&o(`[pitvP]: ${e.P}`,"debug"),i.withValue(()=>i.value)))),F=u("pitvI",(e,n,t)=>t.withHap(i=>(e.I=n,o(`[pitvI]: ${e.I}`,"debug"),i.withValue(()=>i.value)))),x=u("pitvT",(e,n,t)=>t.withHap(i=>(e.T=n,a&&o(`[pitvT]: ${e.T}`,"debug"),i.withValue(()=>i.value)))),L=u("pitvV",(e,n,t)=>t.withHap(i=>(e.V=n,a&&o(`[pitvV]: ${e.V}`,"debug"),i.withValue(()=>i.value)))),D=u("pitvNV",(e,n)=>n.withHap(t=>{let i;try{i=w(t)}catch{o("[pitvNV] not a note!","warning");return}let r=$(i),l=e.toChord(e.P,e.I,e.T,e.V,!0).get(0),c=d.closestPitch(r,l),s=t.withValue(()=>c);return a&&o(`[pitvNV]: old note: ${r} new note: ${c} result.value: ${s.value}`,"debug"),s})),R=u("pitvN",(e,n)=>n.withHap(t=>{let i;try{i=w(t)}catch{o("[pitvNV] not a note!","warning");return}let r=$(i),c=e.toChord(e.P,e.I,e.T,e.V,!1).get(1).epcs(),s=d.conformToPitchClassSet(r,c),g=t.withValue(()=>s);return a&&o(`[pitvN]: old note: ${r} new note: ${s} result.value: ${g.value}`,"debug"),g}));export{b as chordI,N as chordK,k as chordN,H as chordNV,I as chordQ,T as chordT,p as csacChord,h as csacCopy,y as csacDebugging,m as csacLoad,Q as csacPitv,C as csacScale,$ as frequencyToMidiInteger,V as frequencyToMidiReal,F as pitvI,R as pitvN,D as pitvNV,z as pitvP,x as pitvT,L as pitvV,q as scaleM,K as scaleN,M as scaleS,O as scaleT};
