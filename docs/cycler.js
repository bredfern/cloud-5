/**
  * This file implements real-time and/or "always-on" score generation for 
  * cloud-music. Time is provided by `performance.now`.
  * 
  * Author: Michael Gogins
  * Copyright: 2023.
  * Licence: GNU Lesser General Public License, version 2.1.
  *
  * Algorithm
  * ---------
  *
  * This algorithm is _very_ loosely inspired by Tidal Cycles. The algorithm 
  * is concerned only with generating and processing Events, which are 
  * numerical vectors that correspond directly to Csound "i" statements, 
  * usually notes. Control signals can be generated either within Csound 
  * instruments, or as JavaScript calls to `Csound.setChannelValue`. 
  *
  * By using Csound for almost all scheduling, the poor resolution and jitter 
  * of JavaScript timers, which have been imposed as defenses against timing-
  * based attacks, affect only the repeat times of cycles.
  *
  * A composition is a directed acyclic graph of Nodes that generate Events 
  * for a Score that is periodically sent to Csound. Each Node has a nominal 
  * offset, defaulting to 0, and a nominal interval, defaulting to 1. Any Node 
  * can either generate Events, or transform Events produced by its child 
  * Nodes, or both. Parent nodes can have any number of child Nodes, and child 
  * Nodes can have any number of parent Nodes. 
  *
  * The fundamental types of Nodes are:
  *
  * 1. Cycles, which repeat indefinitely. An always-on piece is created when 
  *    the root Node of the piece is a Cycle. Any number of Cycles can run at 
  *    the same time, and at different intervals.
  * 2. Sequences, where adding (or repeating) child Nodes expands the duration 
  *    of the parent Sequence to equal the sum of intervals of its child 
  *    Nodes.
  * 3. Nests, where adding (or repeating) child Nodes squeezes the child Nodes 
  *    to fit within the interval of the parent Nest. 
  *
  * The main loop is:
  *
  * 1. Reset all times, and then traverse the tree to determine the interval 
  *    of the root Node. Please note, if the root Node is a Cycle, its 
  *    interval will default to the sum of the intervals of its child Nodes.
  * 2. Assign the current value of `Player.current_time` to 
  *    `Player.times.performance.current`.
  * 3. Clear `Player.score`.
  * 4. Perform a depth-first traversal of the tree of Nodes by calling 
  *    `Player.root.traverse`. At each level of the tree, for each child Node:
  *    a. Call `child.traverse`, which will normally descend recursively to 
  *       the leaf nodes of the tree.
  *    b. Call `this.generate`.
  *    c. Call `this.transform`.
  *    d. Push generated and/or transformed Events onto the Score.
  * 5. After the traversal, rescale the duration of the Score by multiplying 
  *    offsets and intervals by `Player.tempo_factor`.
  * 6. Call `Player.csound.readScore` to send the Score to Csound.
  * 7. Assign `Player.times.performance.current` to 
  *    `player.times.performance.prior`. 
  * 8. Assign the value of `Player.current_time` to 
  *    `Player.times.performance.current`.
  * 9. Subtract `Player.times.performance.prior` from 
  *    `Player.times.performance.current` to obtain the time spent 
  *    performing steps 1 through 7, and assign that time to 
  *   `Player.times.current.compute_time`.
  * 10.Call `setInterval(Player.times.interval - Player.times.current.compute_time, 
  *    Player.root.traverse)` to schedule the next cycle.
  */
  
/**
  * Base class for for all Nodes.
  */
class Node {
  constructor() {
    this.children = new Array();
    this.times = {nominal: {}, cycle: {}, performance: {}};
    // A cycle has a nominal duration of 1.
    this.times.nominal.offset = 0;
    this.times.nominal.current = 0;
    this.times.nominal.duration = 1;
    // A cycle has an actual duration = nominal * seconds_per_cycle.
    // This is in real seconds, but resets to 0 at the start of each _cycle_.
    this.times.cycle.offset = 0;
    this.times.cycle.current = 0;
    this.times.cycle.duration = 1;
    // Performance time is in real seconds, counting from 0 at the start of 
    // the performance.
    this.times.performance.offset = 0;
    this.times.performance.current = 0;
    this.times.performance.duration = 1;
    // Contains Events that begin after the interval of this.
    this.pending_events = new CsoundAC.Score();
  };
  /**
    * Returns true if this should generate Events. The default implementation 
    * always returns true.
    */
  predicate() {
    return true;
  };
  /**
    * Applies some transformation to the child Events of this. The default 
    * implementation does nothing.
    */
  transform(score) {
  }
  /**
    * If predicate returns true, generates and/or transforms Events and adds 
    * them to the Score. The default implementation does nothing. Events 
    * generated by this and its child Nodes are rescaled to fit within the 
    * interval of this.
    */
  generate(score) {
  };
  /**
    * Performs a depth-first traversal of the tree defined by this and its 
    * child Nodes. The default implementation does nothing. Derived Nodes 
    * must override this function. But in all cases, the times of the parent 
    * (e.g. Sequence) or of this (e.g. Nest) must first be computed, then 
    * the predicate is evaluated, then if that is true, first generate and 
    * then transform are called.
    */
  traverse(parent, score) {
  };
};

/**
  * Performs the immediate child nodes of this in sequence. The interval of 
  * this is the sum of the intervals of its _immediate_ children. When the 
  * end of the last child is reached, the nominal time of this is reset to 0.
  */
class Sequence extends Node {
};

/**
  * Performs the immediate child nodes of this in sequence. The intervals of 
  * the _immediate_ child nodes of this are rescaled so that their sum equals 
  * the interval of this. When the end of the last child is reached, the 
  * nominal time of this is reset to 0.
  */
class Nest extends Sequence {
};

/**
  * Performs the _immediate_ child nodes of this in a repeating loop. The 
  * Cycle may have an interval that differs from the sum of the intervals of 
  * its _immediate_ child nodes. When the end of the last child is reached, 
  * Events that are still pending are saved, and the offset of this is 
  * adjusted.
  */
class Cycle extends Node {
  traverse(parent, score) {
  }
};

class Player extends Node {
  constructor(csound) {
    this.csound = csound;
    this.keep_running = false;
    // Tempo in seconds per cycle. The default value is basically 8 bars of 
    // 4/4 at 120 bpm. In actual pieces this time can be much longer.
    this.seconds_per_cycle = 16;
    this.events = new CsoundAC.Score();
    this.divisions_per_octave = 12;
    this.round_pitches = true;
  };
  /**
    * Pushes the child Node onto the list of immediate children of the parent. 
    * The default child cycle duration is 1. However, times are not adjusted 
    * until performance.  
    */
  append(parent, child, child_cycle_duration) {
    if (parent === this) {
      this.children.push(parent);
    }
    parent.children.push(child);
    parent.player = this;
    child.player = this;
    if (typeof child_cycle_duration !== 'undefined') {
      child.cycle_duration = child_cycle_duration;
    }
  };
  current_time() {
    return performance.now() / 1000;
  }
  performance_time() {
    return this.current_time() - this.starting_time();
  }
  start() {
    this.keep_running = true;
    this.starting_time = performance.now() / 1000; 
  }
  stop() {
    this.keep_running = false;
  }
  render() {
    // Time 0 is the beginning of this cycle, not the beginning of this 
    // performance.
    score_text = this.score.getCsoundScore(this.divisions_per_octave, this.round_pitches);
    this.csound.readScore(score_text);
  }
  /**
    * Generates and renders Events indefinitely, until stopped.
    */
  cycle() {
    if (this.keep_running === false) {
      return;
    }
    this.events.clear();
    // Generate one cycle's worth of pending events, using nominal times.
    this.generate(this.events);
    // Render this cycle's pending events in real time with Csound, using 
    // cycle times.
    this.render();    
    // Schedule the next cycle.
    let next_cycle_time = this.performance_time() + this.cycle_duration;
    setTimer(next_cycle_time, this.cycle);
  }
};