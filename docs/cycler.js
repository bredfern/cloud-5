/**
  * This file implements real-time and/or "always-on" score generation for 
  * cloud-music. Time is provided by `performance.now`.
  * 
  * Author: Michael Gogins
  * Copyright: 2023.
  * Licence: GNU Lesser General Public License, version 2.1.
  *
  * Algorithm
  * ---------
  *
  * This algorithm is _very_ loosely inspired by Tidal Cycles. Thids algorithm 
  * is concerned only with generating and processing Events, which are 
  * numerical vectors that correspond directly to Csound "i" statements, 
  * usually notes (control signals can be generated either within Csound 
  * instruments, or as JavaScript calls to `Csound.setChannelValue`). 
  *
  * By using Csound for almost all scheduling, the poor resolution and jitter 
  * of JavaScript timers, which have been imposed as defenses against timing-
  * based attacks, can affect only the repeat times of cycles.
  *
  * A composition is a directed acyclic graph of Nodes that generate Events 
  * for a Score that is periodically sent to Csound. Each Node has a nominal 
  * offset, defaulting to 0, and a nominal interval, defaulting to 1. Any Node 
  * can either generate Events, or transform Events produced by its child 
  * Nodes, or both. Parent nodes can have any number of child Nodes, and child 
  * Nodes can have any number of parent Nodes. 
  *
  * The composer must derive new classes from Node, in which he or she defines 
  * the generation and/or transformation of Events in the piece.
  *
  * The fundamental types of Nodes are:
  *
  * 1. Node (base class).
  * 2. Sequence, where adding (or repeating) child Nodes expands the interval 
  *    of the parent Sequence to equal the sum of intervals of its child 
  *    Nodes.
  * 3. Nest, where adding (or repeating) child Nodes squeezes the child Nodes 
  *    to fit within the interval of the parent Nest. 
  * 4. Cycle, which repeats all child Events indefinitely, using a cycle 
  *    interval that may differ from the nominal interval; two or more Cycles 
  *    may thus be used to implement differential canons and other structures.
  */
  
/**
  * Base class for for all Nodes.
  */
class Node {
  constructor() {
    this.parent = null;
    this.children = new Array();
    this.times = {nominal: {}, cycle: {}};
    // Nominal times default to 0 and 1, but may be defined by the composer, 
    // and afterwards will remain unchanged; they form the basis for computing 
    // cycle times.
    this.times.nominal.offset = 0;
    this.times.nominal.interval = 1;
    // Cycle times are obtained when the nominal times are rescaled to expand 
    // parent Nodes or squeeze child Nodes during traversal of the tree. 
    // Performance times are obtained by multiplying cycle times by seconds 
    // per cycle.
    this.times.cycle.offset = 0;
    this.times.cycle.interval = 1;
  };
  /**
    * Pushes the child Node onto the children of this.
    */
  add_child(child) {
    child.parent = this;
    this.children.push(child);
  }
  /**
    * Adjusts the cycle times of this and/or the children of this 
    * to fit each other. The default implementation does nothing.
    */
  update_times() {
  }
  /**
    * Generates Events and pushes them onto the Score. The default 
    * implementation does nothing. 
    */
  generate(score) {
  };
  /**
    * Applies some transformation to all Events generated by this and the 
    * child Nodes of this. Such transformations should not affect times. The 
    * default implementation does nothing.
    */
  transform(score) {
  }
  /**
    * Rescales the times of _only_ those Events _generated_ by this Node to 
    * fit within the interval of this.
    */
  rescale_times(score, start_index, end_index) {
    // The rescaling of onsets and durations is performed using cycle times.
    let events_interval = 0;
    for (let i = start_index; i < end_index; ++i) {
      if (events_interval < score[i].getOffTime()) {
        events_interval = score[i].getOffTime();
      };
    }
    const ratio = this.times.cycle.interval / events_interval;
    for (let i = start_index; i < end_index; ++i) {
      let onset = score[i].getTime();
      score[i].setTime(onset * ratio);
      let duration = score[i].getDuration();
      score[i].setDuration(duration * ratio);
    };
  };
  /**
    * Traverses the tree defined by this and its child Nodes. 
    */
  traverse(score) {
    // Adjust times of this and its immediate children (done from the top 
    // down).
    this.update_times();
    // Recursively traverse all sub-trees.
    for (let child of this.children) {
      child.traverse(score);
    };
    // Optionally, generate Events and push them on the Score (done from the 
    // bottom up).
    const begin_index = score.length;
    this.generate(score);
    const end_index = score.length;
    // Rescale the times of any Events generated by this.
    this.rescale_times(begin_index, end_index;
    // Optionally, transform _all_ child Events of this; this transformation 
    // should not change times.
    this.transform(score);
  };
};

/**
  * Performs the immediate child nodes of this in sequence. The interval of 
  * this is the sum of the intervals of its _immediate_ children. 
  */
class Sequence extends Node {
  update_times() {
    let total_interval = 0;
    for (let child of this.children) {
      total_interval += child.times.cycle.interval;
    }
    this.times.cycle.interval = total_interval;
   }
};

/**
  * Performs the immediate child nodes of this in sequence. The intervals of 
  * the _immediate_ child nodes of this are rescaled so that their sum equals 
  * the interval of this. 
  */
class Nest extends Sequence {
  update_times() {
    let children_interval = 0;
    for (let child of this.children) {
      children_interval += child.times.cycle.interval;
    }
    const ratio = this.times.cycle.interval / children_interval;
    for (let child of this.children) {
      child.times.cycle.interval *= children_interval;
    }
  }
};

/**
  * Contains an inner Nest that may have cycle times that differ from the 
  * times of the outer Nest (i.e. this). Child Nodes added to this are 
  * actually added to the inner Nest.
  */
class Cycle extends Nest {
  constructor() {
    super();
    this.inner_node = new Nest();
    this.inner_score = new CsoundAC.Score();
  };
  add_child(child) {
    this.inner_node.add_child(child);
  }
  update_times() {
    this.update_times();
    this.inner_node.update_times();
    
  }
  advance(score.offset) {
    for (let i = 0; i < score.length; ++i) {
      let onset = score[i].getTime() + offset;
      score[i].setTime(onset);
    }
  }
  traverse(score) {
    // While the outer offset is less than the outer interval, traverse the 
    // inner tree with the inner Score.
    while (this.times.cycle.offset < this.times.cycle.interval) {
      // Clear the inner Score.
      this.inner_score.length = 0;
      this.inner_node.traverse(inner_score);
      // Advance all Events in the inner Score by the offset,
      // and move them to the outer Score.
      this.advance(this.inner_score, this.times.cycle.offset);
      score.push(this.inner_score);
      // Advance the offset by the _inner_ interval.
      this.times.cycle.offset = this.times.cycle.offset + this.inner_node.times.cycle.interval;
    }
    // Set the offset to the offset modulo the _outer_ interval.
    this.times.cycle.offset = this.times.cycle.offset % this.times.cycle.interval;
  };
};

/**
  * A Player is also the root node of its tree. The root node is thus a Nest. 
  * To create an always-on piece, the root must contain at least one Cycle, 
  * which may contain other Nodes.
  */
class Player extends Nest {
  constructor(csound) {
    this.csound = csound;
    this.keep_running = false;
    // Tempo in seconds per cycle. The default value is basically 8 bars of 
    // 4/4 at 120 bpm. In actual pieces this time will usually be much longer.
    this.seconds_per_cycle = 16;
    this.score = new CsoundAC.Score();
    this.divisions_per_octave = 12;
    this.round_pitches = true;
    this.starting_time = 0;
  };
  /**
    * Pushes the child Node onto the list of immediate children of the parent. 
    * Times are not adjusted until performance.  
    */
  append(parent, child) {
    parent.add_child(child);
    parent.player = this;
    child.player = this;
  };
  current_time() {
    return performance.now() / 1000;
  }
  performance_time() {
    return this.current_time() - this.starting_time();
  }
  start() {
    this.keep_running = true;
    this.starting_time = this.current_time();
    this.cycle();
  };
  stop() {
    this.keep_running = false;
  }
  /**
    * Sends Events generated during the current traversal to Csound.
    */
  render() {
    // Time 0 is the beginning of this cycle, not the beginning of this 
    // performance. Rescales the generated score to fit its cycle interval 
    // in real seconds.
    this.score.setDuration(this.times.cycle.interval * this.times.seconds_per_cycle);
    score_text = this.score.getCsoundScore(this.divisions_per_octave, this.round_pitches);
    this.csound.readScore(score_text);
  }
  /**
    * Generates, transforms, and renders Events, until stopped.
    */
  cycle() {
    // Keep track of time spent computing this cycle.
    const compute_start = this.current_time();
    if (this.keep_running === false) {
      return;
    }
    this.score.clear();
    // Generate and/or transform one cycle's worth of events, using cycle 
    // times.
    this.traverse(this.events);
    // Render this cycle's pending events in real time with Csound, using 
    // real times.
    this.render();    
    // Schedule the next cycle in real seconds.
    const compute_end = this.current_time();
    const compute_time = compute_end - compute_time;
    const cycle_interval = this.times.cycle.interval * this.times.cycle.seconds;
    const timer_interval = cycle_interval - compute_time;
    setTimer(timer_interval, this.cycle);
  }
};