/**
  * This file implements real-time and/or "always-on" score generation for 
  * cloud-music. The purpose is to adapt existing CsoundAC score generation 
  * and transformation facilities, especially the chord space facilities, to 
  * indefinite, real-time looping.
  * 
  * Author: Michael Gogins
  * Copyright: 2023.
  * Licence: GNU Lesser General Public License, version 2.1.
  *
  * Algorithm
  * ---------
  *
  * This algorithm is _very_ loosely inspired by Tidal Cycles. This algorithm 
  * is concerned only with generating and processing Events; these are 
  * numerical vectors that correspond directly to Csound "i" statements, 
  * usually notes. 
  *
  * Another difference is that Tidal Cycles resolves every note to its own 
  * leaf node in the graph to be performed; whereas here, any node, even leaf 
  * nodes, may contain processes or scores that produce multiple notes.
  *
  * As for control signals, they can either be generated within Csound 
  * instruments, or sent to Csound from JavaScript via 
  * `Csound.setChannelValue`.
  *
  * The basic idea is that a composition is a directed acyclic graph of Nodes:
  * a plain Node, a Sequence, a Stack, or a Cycle. Any Node may optionally 
  * generate Events and/or transform Events. A Sequence, as its name implies, 
  * performs its immediate child Nodes in sequence. A Stack performs its 
  * immediate child Nodes at the same time. A Cycle repeats either 
  * indefinitely, or a fixed number of times. Only Cycles schedule and render 
  * Events. Therefore, every composition must include at least one Cycle; but 
  * different Cycles may repeat at different intervals.
  *
  * Each Node has a Score into which Events are generated and within which 
  * Events are transformed. The Scores of child Nodes are appended to the 
  * Score of their parent node, and so on, recursively.
  *
  * As a Cycle repeats, it resets its local cycle time to 0 and recursively 
  * generates and/or transforms Events from the bottom of its graph of Nodes 
  * up to the Cycle root. The current cycle time is propagated down the graph 
  * of Nodes and is used to schedule the different Scores in sync with the 
  * master Score of the Cycle. Only Sequence Nodes advance the cycle time,
  * all other Nodes reset the cycle time to 0.
  *
  * In addition to this recursive subdivision of cycle time, each Node fits 
  * all Events generated by itself and its child Nodes into the cycle 
  * interval. The duration of the child Node may be left independent of the 
  * parent Node, or the duration of the parent may be expanded to match the 
  * duration of the child, or the duration of the child may be squeezed to 
  * match the duration of the parent. Also, the duration of the Node's Score 
  * may be padded by a silent delay at the beginning of the cycle, and/or a 
  * silent extension of time at the end of the interval.
  */
  
var AudioContext = window.AudioContext || window.webkitAudioContext;
var audioContext = new AudioContext();
var cycler_logging_enabled = true;
  
function cycler_log() {
  if (cycler_logging_enabled === true) {
    const current_time = audioContext.currentTime;
    const formatted = sprintf(...arguments);
    const text = sprintf("[cycler][%9.4f] %s", current_time, formatted);
    console.log(text);
  }
}

/**
  * Base class for all Nodes. Each Node consumes a segment of the parent 
  * Node's cycle interval. This interval is computed in different ways for 
  * different methods of scheduling. Exactly one method of scheduling must
  * be chosen for each Node in the graph.
  */
class Node {
  constructor() {
    this.children = new Array();
    /**
      * The Score contains all Events generated not only by this Node, but 
      * also by all Events generated by all of this Node's child Nodes.
      */
    this.score = new CsoundAC.Score();
     /**
      * The times of all Events in the Score are rescaled by this factor. 
      * The default is not to rescale.
      */
    this.time_scale = 1;
    /** 
      * The duration from zero of the Score.
      */
    this.time_score_duration = 0;
    /**
      * Defines the basic interval of this segment, usually but not always 
      * the duration from zero of this Score.
      */
    this.time_segment = 0;
    /**
      * The number of seconds that the onset of the segment is delayed.
      */
    this.time_delay = 0;
    /**
      * The number of seconds of silence following the segment 
      * before the onset of the next cycle.
      */
    this.time_extension = 0;
    /**
      * The total interval of this segment:
      * time_segment_interval = time_delay + time_segment + time_extension.
      */
    this.time_segment_interval = 0;
    /**
      * The child Nodes of this advance recursively through 
      * time_segment_interval, starting at time 0 and subdividing, rescaling, 
      * or resetting the time.
      */
    this.time_cycle = 0;
    /**
      * Disregard the duration of the Score, and schedule at the interval:
      * time_segment_interval = time_delay + time_segment + time_extension. 
      */
    this.schedule_fixed = false;
    /**
      * Assign the current duration of the Score from zero to 
      * time_segment, and schedule at the interval:
      * time_segment_interval = time_delay + time_segment + time_extension.
      * This is the default.
      */
    this.schedule_from_score = true;
    /**
      * Rescale the score to fit within the interval time_score_duration, 
      * assign that value to time_segment, and schedule at the interval:
      * time_segment_interval = time_delay + time_segment + time_extension.
      */
    this.schedule_rescale_score = false;
    
  };
  /**
    * Adds the child Node to the list of immediate children of this.
    */
  add_child(child) {
    this.children.push(child);
  }
  /**
    * Called by the Player recursively to begin the performance. The default 
    * implementation does nothing but recursively call this method.
    */
  start(csound) {
    for (let child of this.children) {
      child.start(csound);
    }
  }
  /**
    * Called by the Player recursively to stop the performance. The default 
    * implementation does nothing but recursively call this method.
    */
   stop() {
    for (let child of this.children) {
       child.stop();
    }
  }
  /**
    * Optionally generates Events and pushes them onto the Score. The 
    * times of the Events are assumed to start at 0 and their durations are 
    * set by code, but the Score times may later be rescaled and/or delayed.
    * The default implementation does nothing.
    */
  generate(score) {
  };
  /**
    * Optionally transforms some or all Events in the Score. The default 
    * implementation does nothing.
    */
  transform(score) {
  };
  /**
    * Optionally rescales the Score times and updates the segment interval.
    */
  rescale_segment(score, depth) {
    cycler_log("%s[Node.rescale_segment]...", '  '.repeat(depth));
    let original_duration = score.getDurationFromZero();
    if (this.time_scale !== 1) {
      let rescaled_duration = original_duration * this.time_scale;
      score.setDurationFromZero(rescaled_duration);
      cycler_log("%s[Node.rescale_segment] original duration: %12.6f rescaled duration: %12.6f", '  '.repeat(depth), original_duration, rescaled_duration);
    } 
    if (this.schedule_fixed === true) {
      // No operation.
    } else if (this.schedule_from_score === true) {
      this.time_score_duration = score.getDurationFromZero();
      this.time_segment = this.time_score_duration;
    } else if (this.schedule_rescale_score === true) {
      score.setTimeFromZero(this.time_score_duration);
      this.time_segment = this.time_score_duration;
    }
    this.time_segment_interval = this.time_delay + this.time_segment + this.time_extension;
    cycler_log("%s[Node.rescale_segment] segment interval: %12.6f delay: %12.6f segment: %12.6f extension: %12.6f", '  '.repeat(depth), this.time_segment_interval, this.time_delay, this.time_segment, this.time_extension);
  }
  /**
    * Updates both the cycle time and the segment interval of this. The 
    * default schedules child Nodes in sequence.
    */
  update_cycle_time(child) {
    this.time_segment_interval = this.time_segment_interval + child.time_segment_interval;
    this.time_cycle = this.time_cycle + child.time_segment_interval;
  }
  /**
    * Schedules the child Score, taking into account the current cycle time 
    * and any time delay.
    */
  schedule_child(child) {
    for (let i = 0, n = child.score.size(); i < n; ++i) {
      let event = child.score.get(i);
      let event_time = event.getTime();
      let new_event_time = child.time_cycle + child.time_delay + event_time;
      event.setTime(new_event_time);
      child.score.set(i, event);
    }
  }
  /**
    * Recursively calls traverse, generate, and transform, advancing the cycle  
    * time as required. At the root node, the cycle time always starts at 0. 
    */
  traverse(cycle_time, depth) {
    cycler_log("%s[Node.traverse] cycle_start: %12.6f depth: %5d", '  '.repeat(depth), cycle_time, depth);
    this.score.clear();
    this.time_cycle = cycle_time;
    this.time_segment_interval = 0;
    for (let i = 0, n = this.children.length; i < n; ++i) {
      // Accumulate Events from child Nodes.
      let child = this.children[i];
      child.traverse(cycle_time, depth + 1);
      // Optionally, rescale the child Score.
      child.rescale_segment(child.score, depth);
      // Schedule the child Score.
      this.schedule_child(child);
       // Transfer all Events from the child Score to this Score.
      for (let i = 0, n = child.score.size(); i < n; ++i) {
        let child_event = child.score.get(i);
        this.score.append_event(child_event);
      }
      // Depending on the type of _this_ Node, reset or advance the cycle times
      // from the _child_ times.
      this.update_cycle_time(child);
      cycler_log("%s[Node.traverse] child[%4d].score:\n%s", '  '.repeat(depth), i, child.score.toString());
    };
    // Optionally, generate own Events and push them on this Score.
    this.generate(this.score);
    // Optionally, transform all Events in this Score.
    this.transform(this.score);
    cycler_log("%s[Node.traverse] this.score:\n%s", '  '.repeat(depth), this.score.toString());
    cycler_log("%s[Node.traverse] cycle interval: %12.6f delay: %12.6f segment: %12.6f extension: %12.6f", '  '.repeat(depth), this.time_segment_interval, this.time_delay, this.time_segment, this.time_extension);
  };
};

/**
  * Performs the immediate child Nodes of this simultaneously. The traversal 
  * times of the immediate child Nodes may differ from from each other,  
  * enabling the traversal times of those children to go out of phase and back 
  * into phase with the traversal times of this. Enables differential canons 
  * and other temporal structures, as well as contrapuntal sequences.
  */
class Stack extends Node {
  constructor() {
    super();
  }
  /**
    * Resets the cycle time and interval to play child Scores simultaneously. 
    */
  update_cycle_time(child) {
    this.time_segment_interval = child.time_segment_interval;
    this.time_cycle = 0;
  }
};

/**
  * Repeatedly traverses the tree rooted in this Node, and renders the 
  * generated Score using Csound. The cycle repeats at the interval of 
  * its root node: `Node.time_segment_interval`. This interval is recursively 
  * subdivided at each level of recursion.
  */
class Cycle extends Node {
  constructor() {
    super();
    // This can be changed to define other systems of equal temperament.
    this.divisions_per_octave = 12;
    // Not to be confused with divisions per octave for equal temperament!
    this.conform_pitches = false;
    this.starting_time = 0;
    this.cycle_count = 0;
    // The number of times this Cycle will repeat; a negative value means 
    // loop indefinitely. The default is to loop indefinitely.
    this.cycles = -1;
  }
  current_time() {
    return audioContext.currentTime;
  }
  performance_time() {
    return this.current_time() - this.starting_time;
  }
  start(csound) {
    cycler_log("[Cycle.start]");
    this.csound = csound;
    this.repeat = true;
    this.cycle_count = 0;
    this.starting_time = this.current_time();
    this.current_performance_time = this.performance_time();
    this.prior_performance_time = this.performance_time();
    this.expected_performance_time = this.performance_time();
    this.time_segment_interval = 0;
    this.prior_cycle_duration = 0;
    this.begin_compute_time = 0;
    this.end_compute_time = 0;
    this.cycle();
    super.start();
  }
   stop() {
    cycler_log("[Cycle.stop]");
    this.repeat = false;
    super.stop();
  }
  /**
    * Sends Events generated by the current traversal to Csound for rendering.
    */
  render() {
    this.prior_performance_time = this.current_performance_time;
    this.prior_cycle_duration = this.time_segment_interval;
    const score_text = this.score.getCsoundScore(this.divisions_per_octave, this.conform_pitches);
    // As close as possible to when Csound actually starts rendering _this_ cycle.
    this.current_performance_time = this.performance_time();
    this.csound.readScore(score_text);
    // As close as possible to when Csound should start rendering the _next_ cycle.
    this.expected_performance_time = this.prior_performance_time + this.time_segment_interval;
    cycler_log("[Cycle.render] prior cycle duration: %12.6f current cycle duration: %12.6f", this.prior_cycle_duration, this.time_segment_interval);
    cycler_log("[Cycle.render] prior rendering time: %12.6f current rendering time: %12.6f next rendering time: %12.6f", this.prior_performance_time, this.current_performance_time, this.expected_performance_time);
    cycler_log("[Cycle.render] score size:          %6d", this.score.size());
  }
  /**
    * Generates, transforms, and renders Events, until stopped.
    */
  cycle() {
    // Find the amount of time spent computing this traversal.
    this.begin_compute_time = this.performance_time();
    if (this.cycles !== -1) {
      if (this.cycle_count >= this.cycles) {
        this.stop();
        return;
      }
    }
    if (this.repeat === false) {
      this.stop();
      return;
    }
    this.cycle_count = this.cycle_count + 1;
    // A Cycle is always the root of its graph with respect to actual 
    // scheduling and rendering, starting at cycle 1, cycle time 0, and 
    // depth 1.
    const cycle_time = 0;
    const depth = 1;
    this.traverse(cycle_time, depth);
    this.render();
    // Correct for timer drift, which is measured every cycle.
    let timer_drift;
    if (this.cycle_count > 1) {
      timer_drift = this.expected_performance_time - this.current_performance_time;
    } else {
      timer_drift = 0;
    }
    // The correction applies the drift in reverse.
    let cycle_interval = Math.max(0, this.time_segment_interval - timer_drift);
    // Also correct for compute time.
    this.end_compute_time = this.performance_time();
    const compute_duration = this.end_compute_time - this.begin_compute_time;
    let timer_interval = Math.max(0, cycle_interval - compute_duration);
    cycler_log("[Cycle.cycle] count: %5d cycle interval: %12.6f compute time: %12.6f timer drift: %12.6f timer interval:%9.4f", this.cycle_count, cycle_interval, compute_duration, timer_drift, timer_interval);
    let that = this;
    let closure = function () {
      that.cycle();
    };      
    // Repeat the cycle...
    setTimeout(closure, 1000. * cycle_interval);  
  };    
}

/**
  * Compositions are written by defining Nodes that generate and/or transform 
  * Events (usually notes), and adding these Nodes first to `Player.root`, and 
  * then to children of `root`, and so on recursively. All compositions must 
  * contain an instance of Cycle (the only Node that actually sends Events to 
  * Csound); by default, the root Node of this is a Cycle.
  */
class Player {
/**
  * The constructor takes a defined instance of Csound that has already 
  * compiled its orchestra and is already performing.
  */
  constructor(csound) {
    this.csound = csound;
    // The default root Node is an instance of Cycle; the composer may change that.
    // By default, this Cycle loops indefinitely.
    this.root = new Cycle();
  };
  start() {
    cycler_log("[Player.start]");
    this.root.start(this.csound);
  }
  stop() {
    cycler_log("[Player.stop]");
    this.root.stop();
  }
};






