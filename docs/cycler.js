/**
  * This file implements real-time and/or "always-on" score generation for 
  * cloud-music. Time is provided by performance.now() or by  
  * BaseAudioContext.currentTime.
  * 
  * Author: Michael Gogins
  * Copyright: 2023.
  * Licence: GNU Lesser General Public License, version 2.1.
  *
  * Algorithm
  * ---------
  * 
  * The algorithm described here is very very loosely inspired by Strudel and 
  * Tidal Cycles, but supports neither live coding nor the scheduling of audio 
  * rate or control rate events. The algorithm here is concerned only with 
  * generating and processing Events, which are numerical vectors that 
  * correspond directly to Csound "i" statements. Control signals, when 
  * needed, can be generated either within Csound instruments, or as 
  * JavaScript calls to Csound.setChannelValue. 
  *
  * A piece is a tree of Nodes. Each Node has a nominal duration of 1 (its 
  * cycle) but can have a longer or shorter duration, or begin at an offset 
  * from its nominal cycle. Nodes can also be scheduled to perform from 1 to 
  * an infinite number of times. An always-on piece is created when the root 
  * Node of the piece is scheduled to repeat indefinitely.
  * 
  * Traversal of this tree is governed by two factors: the onsets and 
  * durations of the Nodes, which define a series of possibly varying time 
  * slices, and the hierachical structure of the tree. At the beginning of 
  * each time slice, the tree is traversed from the bottom to the top of the 
  * tree just for Nodes _within that time slice_. This means that Events 
  * produced by a Node that come later than the end of that slice are saved 
  * for processing and rendering in the next time slice. Obviously, the 
  * definition of Nodes with uneven durations will cause the relative onsets 
  * and even their order to change, thus enabling "phase canons." It is even 
  * possible for Nodes to modify the structure of the tree during performance.
  * 
  * At the end of the traversal for a given time slice, the generated Score 
  * is rescaled by a seconds_per_cycle factor and to begin at the current 
  * performance time. The Score is then sent to Csound for rendering in real 
  * time.
  *
  * The actual scheduling of Nodes and Events _should_ have audio sample 
  * precision, and Nodes that follow or contain each other _must never_ be 
  * scheduled out of order. Traversing the tree at every audio sample is  
  * guaranteed to be correct, but would be prohibitively inefficient. 
  * *HARD PART HERE*
  * https://stackoverflow.com/questions/29971898/how-to-create-an-accurate-timer-in-javascript#29972322
  * https://incolumitas.com/2021/12/18/on-high-precision-javascript-timers/
  * These don't look likely to do my job.
  * I just need to accumulate timer callbacks, put them into the correct order by onset,
  * and call the next timers with adjusted intervals.
  */
  
/**
  * Base class for always-on performance nodes.
  */
class Node {
  constructor() {
    this.children = new Array();
    this.times = {nominal: {}, cycle: {}, performance: {}};
    // A cycle has a nominal duration of 1.
    this.times.nominal.start = 0;
    this.times.nominal.current = 0;
    this.times.nominal.duration = 1;
    // A cycle has an actual duration = nominal * seconds_per_cycle.
    // This is in real seconds but resets to 0 at the start of each cycle.
    this.times.cycle.start = 0;
    this.times.cycle.current = 0;
    this.times.cycle.duration = 1;
    // Performance time is real time starting at 0 at the start of the 
    // performance.
    this.times.performance.start = 0;
    this.times.performance.current = 0;
    this.times.performance.duration = 1;
  };
  /**
    * Returns true if this should generate Events. The default implementation 
    * always returns true.
    */
  predicate() {
    return true;
  };
  /**
    * Applies some transformation to the child Events of this. The default 
    * implementation does nothing.
    */
  transform(score) {
  }
  /**
    * If predicate returns true, generates and/or transforms Events and adds 
    * them to the Score. The default implementation does nothing. Events 
    * generated by this and its child Nodes will be rescaled to fit with the 
    * performance time (both start and duration) of this.
    */
  generate(score) {
  };
  /**
    * Performs a depth-first traversal of the tree defined by this and its 
    * child Nodes. The default implementation does nothing. Derived Nodes 
    * must override this function. But in all cases, the times of the parent 
    * (e.g. Sequence) or of this (e.g. Nest) must first be computed, then 
    * the predicate is evaluated, then if that is true first generate and 
    * then transform are called.
    */
  traverse(parent, score) {
  };
};

/**
  * Performs the immediate child nodes of this in sequence. The duration of 
  * this is the sum of the durations of the _immediate_ children. When the 
  * end of the last child is reached, the nominal time of this is reset to 0.
  */
class Sequence extends Node {
};

/**
  * Performs the immediate child nodes of this in sequence. The durations of 
  * the _immediate_ child nodes of this are rescaled so that their sum equals 
  * the duration of this. When the end of the last child is reached, the 
  * nominal time of this is reset to 0.
  */
class Nest extends Sequence {
};

/**
  * Generates the events of the child nodes of this, modifies them in some
  * way, and produces the modified events.
  */
class Apply extends Node {
};

/**
  * Performs the child nodes of this simultaneously. The child nodes may have 
  * different durations, in which case one or more additional timers is used.
  */
class Stack extends Node {
};


/**
  * Performs the child nodes of this simultaneously. The child nodes may have 
  * different durations. Then, modifies the generated events in some way. 
  * Finally, produces both the child events and the modified child events.
  */
class StackApply extends Apply {
};


class Player extends Node {
  constructor(csound) {
    this.csound = csound;
    this.keep_running = false;
    // Tempo in seconds per cycle. The default value is basically 8 bars of 
    // 4/4 at 120 bpm. In actual pieces this time can be much longer.
    this.seconds_per_cycle = 16;
    this.events = new CsoundAC.Score();
    this.divisions_per_octave = 12;
    this.round_pitches = true;
  };
  /**
    * Pushes the child Node onto the list of immediate children of the parent. 
    * The default child cycle duration is 1. However, times are not adjusted 
    * until performance.  
    */
  append(parent, child, child_cycle_duration) {
    if (parent === this) {
      this.children.push(parent);
    }
    parent.children.push(child);
    parent.player = this;
    child.player = this;
    if (typeof child_cycle_duration !== 'undefined') {
      child.cycle_duration = child_cycle_duration;
    }
  };
  
  current_time() {
    return performance.now() / 1000;
  }
  performance_time() {
    return this.current_time() - this.starting_time();
  }
  start() {
    this.keep_running = true;
    this.starting_time = performance.now() / 1000; 
  }
  stop() {
    this.keep_running = false;
  }
  render() {
    // Time 0 is the beginning of this cycle, not the beginning of this 
    // performance.
    score_text = this.score.getCsoundScore(this.divisions_per_octave, this.round_pitches);
    this.csound.readScore(score_text);
  }
  /**
    * Generates and renders Events indefinitely, until stopped.
    */
  cycle() {
    if (this.keep_running === false) {
      return;
    }
    this.events.clear();
    // Generate one cycle's worth of pending events, using nominal times.
    this.generate(this.events);
    // Render this cycle's pending events in real time with Csound, using 
    // cycle times.
    this.render();    
    // Schedule the next cycle.
    let next_cycle_time = this.performance_time() + this.cycle_duration;
    setTimer(next_cycle_time, this.cycle);
  }
};