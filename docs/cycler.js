/**
  * C Y C L E R
  * 
  * Author: Michael Gogins
  * Copyright: 2023.
  * Licence: GNU Lesser General Public License, version 2.1.
  *
  * Cycler implements real-time and/or "always-on" score generation for 
  * cloud-music, a 100% HTML5 environment for computer music and algorithmic 
  * composition.
  *
  * Cycler is _very_ loosely inspired by Tidal Cycles. However, Cycler is not 
  * designed for live coding. Instead, the purpose is to adapt existing 
  * CsoundAC score generation and transformation facilities, especially the 
  * chord space stuff, to indefinite, real-time looping in the HTML5 
  * environment.
  * 
  * Algorithm
  * ---------
  *
  * Cycler is concerned only with generating and processing Events; these are 
  * numerical vectors that correspond directly to Csound "i" statements, 
  * usually notes. (As for control signals, they can either be generated 
  * within Csound instruments, or sent to Csound from JavaScript via 
  * `Csound.setChannelValue`.)
  *
  * Another difference is that Tidal Cycles resolves every note to its own 
  * leaf node in the rendering graph; whereas here, any node, even leaf nodes, 
  * may contain processes or scores that produce multiple notes.
  *
  * The basic idea is that a composition is a directed acyclic graph of Nodes:
  * the base Node class, a Stack, a Rest, or a Cycle. Any Node may optionally 
  * generate Events and/or transform Events. Each Node has an associated 
  * duration that may be set in several different ways. A base Node performs 
  * its immediate child Nodes in sequence, in order of insertion. A Stack 
  * performs its immediate child Nodes simultaneously. A Cycle repeats its 
  * child Nodes (of any kind) either indefinitely, or for a fixed number of 
  * times. There is also a Rest node that adds a silent Node to a sequence. 
  * Only Cycles actually schedule and render Events. Therefore, every 
  * composition must include at least one Cycle; but a composition may include 
  * multiple Cycles, which can repeat at different intervals.
  *
  * Compositions are by no means limited to unvarying repetitions of one 
  * cycle. Not only may multiple cycles run at different intervals to produce 
  * differential canons and other temporal structures, but the score 
  * generators and processors that the composer defines in Nodes can use 
  * chance operations and/or chaos, or even modify the graph of the piece as 
  * it performs.
  *
  * As a Cycle repeats, it resets its cycle time to 0 and recursively 
  * generates and/or transforms Events from the bottom of its graph of Nodes 
  * up to the root of the graph. Each Node has a Score into which Events are 
  * generated and within which Events are transformed. The Scores of child 
  * Nodes are appended to the Score of their parent node, and so on, 
  * recursively. The Node durations propagate from the bottom of the 
  * graph up, with optional rescaling, but the current cycle time is 
  * propagated from the root at the top of the graph down, and is used to 
  * schedule the different Scores in sync with the master timing of the Cycle. 
  *
  * In addition to this recursive subdivision of cycle time, each Node fits 
  * all Events generated by itself and its child Nodes into its alloted 
  * duration. The duration of the child Node may be left independent of the 
  * parent Node, or the duration of the parent may be expanded to match the 
  * duration of the child, or the duration of the child may be squeezed to 
  * match the duration of the parent. 
  */
  
var AudioContext = window.AudioContext || window.webkitAudioContext;
var audioContext = new AudioContext();
var cycler_logging_enabled = true;
  
function cycler_log() {
  if (cycler_logging_enabled === true) {
    const current_time = audioContext.currentTime;
    const formatted = sprintf(...arguments);
    const text = sprintf("[cycler][%9.4f] %s", current_time, formatted);
    console.log(text);
  }
}

/**
  * Base class for all Nodes. Each Node consumes a segment of its parent 
  * Node's duration. This duration is computed in different ways for different 
  * methods of scheduling. Exactly one method of scheduling must be chosen for 
  * each Node in the graph.
  */
class Node {
  constructor() {
    this.children = new Array();
    /**
      * The Score contains all Events generated not only by this Node, but 
      * also by all Events generated by all of this Node's child Nodes.
      */
    this.score = new CsoundAC.Score();
     /**
      * The times of all Events in the Score are rescaled by this factor. 
      * The default is not to rescale.
      */
    this.time_scale = 1;
    /** 
      * The duration from zero of this Score.
      */
    this.time_score_duration = 0;
    /**
      * The total duration of this Node's performance.
      */
    this.time_node_duration = 0;
    /**
      * The child Nodes of this advance recursively through 
      * time_node_duration, starting at time 0 and subdividing, rescaling, 
      * or resetting the cycle time.
      */
    this.cycle_time = 0;
    this.schedule_fixed = false;
    this.schedule_rescale_segment = true;
    this.schedule_rescale_score = false;
  }
  /**
    * Disregard the duration of the Score. This is useful if the Node will 
    * generate a stream of overlapping Events across multiple cycles, so 
    * the node duration that properly segues to the next cycle is not always 
    * the same as the score duration.
    */
  set_schedule_fixed() {
    this.schedule_fixed = true;
    this.schedule_rescale_segment = false;
    this.schedule_rescale_score = false;
  }
/**
  * Assign the current duration of the Score from zero to 
  * time_node_duration.
  */
  set_schedule_from_score() {
    this.schedule_fixed = false;
    this.schedule_rescale_segment = true;
    this.schedule_rescale_score = false;
  }
  /**
    * Rescale the Score to match time_node_duration.
    */
  set_schedule_rescale_score() {
    this.schedule_fixed = false;
    this.schedule_rescale_segment = false;
    this.schedule_rescale_score = true;
  }
  /**
    * Adds the child Node to the list of immediate children of this.
    */
  add_child(child) {
    this.children.push(child);
  }
  /**
    * Called by the Player recursively to begin the performance. The default 
    * implementation does nothing but recursively call this method.
    */
  start(csound) {
    for (let child of this.children) {
      child.start(csound);
    }
  }
  /**
    * Called by the Player recursively to stop the performance. The default 
    * implementation does nothing but recursively call this method.
    */
   stop() {
    for (let child of this.children) {
       child.stop();
    }
  }
  /**
    * Optionally generates Events and pushes them onto the Score. The 
    * times of the Events are assumed to start at 0 and their durations are 
    * set by code, but the Score times may later be rescaled and/or delayed.
    * The default implementation does nothing. If the score is perchance 
    * read from a file or generated just once, keep the original score in 
    * a separate Score and copy it into the Score argument on every call.
    */
  generate(score) {
  };
  /**
    * Optionally transforms some or all Events in the Score. The default 
    * implementation does nothing.
    */
  transform(score) {
  };
  /**
    * Rescales the segment times to match the Score times.
    */
  rescale_segment(score, depth) {
    cycler_log("%s[Node.rescale_segment]...", '  '.repeat(depth));
    if (this.time_scale !== 1) {
      let original_duration = this.score.getDurationFromZero();
      let rescaled_duration = original_duration * this.time_scale;
      score.setDurationFromZero(rescaled_duration);
      cycler_log("%s[Node.rescale_segment] rescaled from original duration: %12.6f to: %12.6f", '  '.repeat(depth), original_duration, rescaled_duration);
    } 
    this.time_node_duration = this.score.getDurationFromZero();
    cycler_log("%s[Node.rescale_segment] node duration: %12.6f", '  '.repeat(depth), this.time_node_duration);
  }
  /**
    * Rescales the Score times to match the segment times.
    */
  rescale_score(score, depth) {
    cycler_log("%s[Node.rescale_score]...", '  '.repeat(depth));
    this.time_score_duration = this.time_node_duration;
    score.setDurationFromZero(this.time_score_duration);
    cycler_log("%s[Node.rescale_score] node duration: %12.6f", '  '.repeat(depth), this.time_node_duration);
  }
  /**
    * Updates both the cycle time and the node duration of this. The 
    * default schedules child Nodes in sequence.
    */
  update_cycle_time(child) {
    this.time_node_duration = this.time_node_duration + child.time_node_duration;
    this.cycle_time = this.cycle_time + child.time_node_duration;
  }
  /**
    * Schedules the child Score, taking into account the current cycle time,
    * and adds it to the Score of this.
    */
  schedule_child(child) {
    for (let i = 0, n = child.score.size(); i < n; ++i) {
      let child_event = child.score.get(i);
      let child_event_time = child_event.getTime();
      let new_child_event_time = this.cycle_time + child_event_time;
      child_event.setTime(new_child_event_time);
      this.score.append_event(child_event);
    }
  }
  /**
    * Recursively calls traverse, generate, and transform, advancing the cycle  
    * times and updating the Node durations as required. At the root node, the 
    * cycle time always starts at 0. 
    */
  traverse(cycle_time, depth) {
    cycler_log("%s[Node.traverse] cycle_start: %12.6f depth: %5d", '  '.repeat(depth), cycle_time, depth);
    this.score.clear();
    this.cycle_time = cycle_time;
    if (this.schedule_fixed === false) {
      this.time_node_duration = 0;
    }
    for (let i = 0, n = this.children.length; i < n; ++i) {
      // Accumulate Events from child Nodes.
      let child = this.children[i];
      child.traverse(cycle_time, depth + 1);
      if (child.schedule_rescale_segment === true) {
        child.rescale_segment(child.score, depth);
      } else if (child.schedule_rescale_score === true) {
        child.rescale_score(child.score, depth);
      } else if (child.schedule_fixed === true) {
        // Do not rescale anything.
      }
      // Schedule the child Score.
      this.schedule_child(child, depth);
      // Depending on the type of _this_ Node, reset or advance the cycle times
      // from the _child_ times.
      this.update_cycle_time(child);
      /// cycler_log("%s[Node.traverse] child[%4d].score:\n%s", '  '.repeat(depth), i, child.score.toString());
    };
    // Optionally, generate own Events and push them on this Score.
    this.generate(this.score);
    // Optionally, transform all Events in this Score.
    this.transform(this.score);
    cycler_log("%s[Node.traverse] this.score:\n%s", '  '.repeat(depth), this.score.toString());
    cycler_log("%s[Node.traverse] cycle interval: %12.6f", '  '.repeat(depth), this.time_node_duration);
  };
};

/**
  * Performs the immediate child Nodes of this simultaneously. The traversal 
  * times of the immediate child Nodes may differ from from each other,  
  * enabling the traversal times of those children to go out of phase and back 
  * into phase with the traversal times of this. Enables differential canons 
  * and other temporal structures, as well as contrapuntal sequences.
  */
class Stack extends Node {
  constructor() {
    super();
  }
  /**
    * Resets the cycle time and interval to play child Scores simultaneously. 
    */
  update_cycle_time(child) {
    this.time_node_duration = child.time_node_duration;
    this.cycle_time = 0;
  }
};

/**
  * Performs an interval of silence within a cycle of Nodes.
  */
class Rest extends Node {
   constructor(duration) {
    super();
    if (typeof duration_ !== 'undefined') {
      this.time_node_duration = duration;
    } else {
      this.time_node_duration = 1;
    }
    // The rest is actually but silently performed by an instrument that has 
    // been defined in the orchestra, so that the rest will be rescaled along 
    // with all other times. If using instrument 1 causes problems, the 
    // composer can assign a different number, or even add a dummy "rest" 
    // instrument to the orchestra.
    this.instrument = 1;
  }
  generate(score) {
    score.add(this.duration, 0, 144, this.instrument, 60, 1, 0, 0, 0, 0, 0);
  }
};

/**
  * Repeatedly traverses the tree rooted in this Node, and renders the 
  * generated Score using Csound. The cycle repeats at the interval of 
  * its root node: `Node.time_node_duration`. This interval is recursively 
  * subdivided at each level of recursion.
  */
class Cycle extends Node {
  constructor() {
    super();
    // This can be changed to define other systems of equal temperament.
    this.divisions_per_octave = 12;
    // Not to be confused with divisions per octave for equal temperament!
    this.conform_pitches = false;
    this.starting_time = 0;
    this.cycle_count = 0;
    // The number of times this Cycle will repeat; a negative value means 
    // loop indefinitely. The default is to loop indefinitely.
    this.cycles = -1;
  }
  current_time() {
    return audioContext.currentTime;
  }
  performance_time() {
    return this.current_time() - this.starting_time;
  }
  start(csound) {
    cycler_log("[Cycle.start]");
    this.csound = csound;
    this.repeat = true;
    this.cycle_count = 0;
    this.starting_time = this.current_time();
    this.current_performance_time = this.performance_time();
    this.prior_performance_time = this.performance_time();
    this.expected_performance_time = this.performance_time();
    this.time_node_duration = 0;
    this.prior_cycle_duration = 0;
    this.begin_compute_time = 0;
    this.end_compute_time = 0;
    this.cycle();
    super.start();
  }
   stop() {
    cycler_log("[Cycle.stop]");
    this.repeat = false;
    super.stop();
  }
  /**
    * Sends Events generated by the current traversal to Csound for rendering.
    */
  render() {
    this.prior_performance_time = this.current_performance_time;
    this.prior_cycle_duration = this.time_node_duration;
    const score_text = this.score.getCsoundScore(this.divisions_per_octave, this.conform_pitches);
    this.csound.inputMessage(score_text);
    // As close as possible to when Csound actually starts rendering _this_ cycle.
    this.current_performance_time = this.performance_time();
    // As close as possible to when Csound should start rendering the _next_ cycle.
    this.expected_performance_time = this.prior_performance_time + this.time_node_duration;
    cycler_log("[Cycle.render] prior cycle duration: %12.6f current cycle duration: %12.6f", this.prior_cycle_duration, this.time_node_duration);
    cycler_log("[Cycle.render] prior rendering time: %12.6f current rendering time: %12.6f next rendering time: %12.6f", this.prior_performance_time, this.current_performance_time, this.expected_performance_time);
    cycler_log("[Cycle.render] score size:          %6d", this.score.size());
    ///cycler_log("[Cycle.render] score:\n%s", this.score.toString());
  }
  /**
    * Generates, transforms, and renders Events, until stopped.
    */
  cycle() {
    // Find the amount of time spent computing this traversal.
    this.begin_compute_time = this.performance_time();
    if (this.cycles !== -1) {
      if (this.cycle_count >= this.cycles) {
        this.stop();
        return;
      }
    }
    if (this.repeat === false) {
      this.stop();
      return;
    }
    this.cycle_count = this.cycle_count + 1;
    // A Cycle is always the root of its graph with respect to actual 
    // scheduling and rendering, starting at cycle 1, cycle time 0, and 
    // depth 1.
    const cycle_time = 0;
    const depth = 1;
    this.traverse(cycle_time, depth);
    this.render();
    // Correct for timer drift, which is measured every cycle.
    let timer_drift;
    if (this.cycle_count > 1) {
      timer_drift = this.expected_performance_time - this.current_performance_time;
    } else {
      timer_drift = 0;
    }
    // The correction applies the drift in reverse.
    let cycle_interval = Math.max(0, this.time_node_duration - timer_drift);
    // Also correct for compute time.
    this.end_compute_time = this.performance_time();
    const compute_duration = this.end_compute_time - this.begin_compute_time;
    let timer_interval = Math.max(0, cycle_interval - compute_duration);
    cycler_log("[Cycle.cycle] count: %5d cycle interval: %12.6f compute time: %12.6f timer drift: %12.6f timer interval:%9.4f", this.cycle_count, cycle_interval, compute_duration, timer_drift, timer_interval);
    let that = this;
    let closure = function () {
      that.cycle();
    };      
    // Repeat the cycle...
    setTimeout(closure, 1000. * cycle_interval);  
  };    
}

/**
  * Compositions are written by defining Nodes that generate and/or transform 
  * Events (usually notes), and adding these Nodes first to `Player.root`, and 
  * then to children of `root`, and so on recursively. All compositions must 
  * contain an instance of Cycle (the only Node that actually sends Events to 
  * Csound); by default, the root Node of this is a Cycle.
  */
class Cycler {
/**
  * The constructor takes a defined instance of Csound that has already 
  * compiled its orchestra and is already performing.
  */
  constructor(csound) {
    this.csound = csound;
    // The default root Node is an instance of Cycle; the composer may change that.
    // By default, this Cycle loops indefinitely.
    this.root = new Cycle();
  };
  start() {
    cycler_log("[Player.start]");
    this.root.start(this.csound);
  }
  stop() {
    cycler_log("[Player.stop]");
    this.root.stop();
  }
};






