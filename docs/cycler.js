/**
  * This file implements real-time and/or "always-on" score generation for 
  * cloud-music. The purpose is to adapt existing CsoundAC score generation 
  * and transformation facilities, especially the chord space facilities, to 
  * indefinite, real-time looping.
  * 
  * Author: Michael Gogins
  * Copyright: 2023.
  * Licence: GNU Lesser General Public License, version 2.1.
  *
  * Algorithm
  * ---------
  *
  * This algorithm is _very_ loosely inspired by Tidal Cycles. This algorithm 
  * is concerned only with generating and processing Events; these are 
  * numerical vectors that correspond directly to Csound "i" statements, 
  * usually notes. 
  *
  * Another difference is that Tidal Cycles resolves every note to its own 
  * leaf node in the graph to be performed; whereas here, any node, even leaf 
  * nodes, may contain processes or scores that produce multiple notes.
  *
  * As for control signals, they can either be generated within Csound 
  * instruments, or sent to Csound from JavaScript via 
  * `Csound.setChannelValue`.
  *
  * The basic idea is that a composition is a directed acyclic graph of Nodes:
  * a plain Node, a Sequence, a Stack, or a Cycle. Any Node may optionally 
  * generate Events and/or transform Events. A Sequence, as its name implies, 
  * performs its immediate child Nodes in sequence. A Stack performs its 
  * immediate child Nodes at the same time. A Cycle repeats either 
  * indefinitely, or a fixed number of times. Only Cycles schedule and render 
  * Events. Therefore, every composition must include at least one Cycle; 
  * different Cycles may repeat at different intervals.
  *
  * Each Node has a Score into which Events are generated and within which 
  * Events are transformed. The Scores of child Nodes are appended to the 
  * Score of their parent node, and so on, recursively.
  *
  * As a Cycle repeats, it resets its local cycle time to 0 and recursively 
  * generates and/or transforms Events from the bottom of its graph of Nodes 
  * up to the Cycle root. The current cycle time is propagated down the graph 
  * of Nodes and is used to schedule the different Scores in sync with the 
  * master Score of the Cycle. Only Sequence Nodes advance the cycle time.
  *
  * In addition to this recursive subdivision of cycle time, each Node fits 
  * all Events generated by itself and its child Nodes into the cycle time. 
  * The duration of the child Node may be left independent of the parent Node, 
  * or the duration of the parent may be expanded to match the duration of the 
  * child, or the duration of the child may be squeezed to match the duration 
  * of the parent. Also, the duration of the Node's Score may be padded by 
  * a silent delay at the beginning of the cycle, and/or a silent extension of 
  * time at the end of the cycle.
  */
  
var AudioContext = window.AudioContext || window.webkitAudioContext;
var audioContext = new AudioContext();
var cycler_logging_enabled = true;
  
function cycler_log() {
  if (cycler_logging_enabled === true) {
    const current_time = audioContext.currentTime;
    const formatted = sprintf(...arguments);
    const text = sprintf("[cycler][%9.4f] %s", current_time, formatted);
    console.log(text);
  }
}

/**
  * Base class for all Nodes.
  */
class Node {
  constructor() {
    this.children = new Array();
    /**
      * The Score will contain all Events generated not only by this Node, 
      * but also by all Events generated by all of this Node's child Nodes.
      */
    this.score = new CsoundAC.Score();
    /**
      * The times of all Events in the Score are rescaled by this factor. The 
      * default is not to rescale.
      */
    this.time_scale = 1;
    /**
      * If this duration is zero, the times of Events in the Score are not 
      * rescaled, but rather the duration of the Score is used as the basis of 
      * the cycle time.  If this duration is greater than zero, the Score is 
      * rescaled to fit this duration, and again the duration of the Score is 
      * used as the basis of the cycle time.  If this duration is less than 
      * zero, the Score is not rescaled, and the absolute value of this 
      * duration is used as the basis of the cycle time, i.e. the Score is 
      * performed at the beginning of the cycle, but otherwise its Events are 
      * independent of the cycle.
      */
    this.time_duration = 0;
    /**
      * If the delay is not zero, the value of the delay in seconds is added 
      * to the time of each Event, thus delaying the performance of the Score.
      * The default is no delay.
      */
    this.time_delay = 0;
    /**
      * If the extension is not zero, the value of the extension in seconds is 
      * added to the duration of the cycle without changing times of Events, 
      * this extending the performance of the Score with silence. The default 
      * is no extension.
      */
    this.time_extend = 0;
  };
  /**
    * Adds the child Node to the list of immediate children of this.
    */
  add_child(child) {
    this.children.push(child);
  }
  /**
    * Called by the Player recursively to begin the performance. The default 
    * implementation does nothing but recursively call this method.
    */
  start(csound) {
    for (let child of this.children) {
      child.start(csound);
    }
  }
  /**
    * Called by the Player recursively to stop the performance. The default 
    * implementation does nothing but recursively call this method.
    */
   stop() {
    for (let child of this.children) {
       child.stop();
    }
  }
  /**
    * Optionally generates Events and pushes them onto the Score. The 
    * times of the Events are assumed to start at 0 and their durations are 
    * set by code, but the Score times may later be rescaled and/or delayed.
    * The default implementation does nothing.
    */
  generate(score) {
  };
  /**
    * Optionally transforms some or all Events in the Score. The default 
    * implementation does nothing.
    */
  transform(score) {
  };
  /**
    * Optionally rescales and/or offsets the Score times. Returns the duration 
    * in seconds of the resulting score. This method takes into account the 
    * delay, but not the cycle time.
    */
  rescale_score(score) {
    cycler_log("[Node.rescale_score]...");
    let original_duration = score.getDurationFromZero();
    let rescaled_duration;
    if (this.time_duration > 0) {
      score.setDurationFromZero(this.time_duration);
    } else if (this.time_scale !== 1) {
      rescaled_duration = original_duration * ratio;
      score.setDurationFromZero(rescaled_duration);
    } 
    if (this.time_delay !== 0) {
      for (let i = 0, n = score.size(); i < n; ++i) {
        let event = score.get(i);
        let current_time = event.getTime();
        let new_time = this.time_delay + current_time;
        event.setTime(new_time);
      }
    }
    rescaled_duration = score.getDurationFromZero();
    cycler_log("[Node.rescale_score] original duration: %12.6f rescaled duration: %12.6f", original_duration, rescaled_duration);
    return rescaled_duration;
  }
  /**
    * Optionally updates the cycle time from the child Score. The default 
    * implementation simply resets the cycle time. 
    */
  update_cycle_time(cycle_time, child_score) {
    return 0;
  }
  /**
    * Recursively calls traverse, generate, and transform, advancing the cycle  
    * time as required. At the root node, the cycle time always starts at 0; 
    * the cycle time is thus recursively updated as the tree is traversed.
    * Returns a Score that includes Events generated and/or transformed 
    * by this and all the child Nodes of this.
    */
  traverse(cycle_time, depth) {
    cycler_log("%s[Node.traverse] cycle_start: %12.6f depth: %5d", '  '.repeat(depth), cycle_time, depth);
    this.score.clear();
    for (let i = 0, n = this.children.length; i < n; ++i) {
      // Accumulate Events from child Nodes.
      let child = this.children[i];
      let child_score = child.traverse(cycle_time, depth + 1);
      // Optionally, rescale the child Score.
      child.rescale_score(child_score);
      // Optionally leave unchanged, advance, or reset the cycle time.
      cycle_time = this.update_cycle_time(cycle_time, child_score);
      // Transfer all Events from the child Score to this Score.
      for (let i = 0, n = child_score.size(); i < n; ++i) {
        let child_event = child_score.get(i);
        this.score.append_event(child_event);
      }
      cycler_log("%s[Node.traverse] child[%4d].score:\n%s", '  '.repeat(depth), i, child.score.toString());
    };
    // Optionally, generate own Events and push them on this Score.
    this.generate(this.score);
    // Optionally, transform all Events in this Score.
    this.transform(this.score);
    cycler_log("%s[Node.traverse] this.score:\n%s", '  '.repeat(depth), this.score.toString());
    return this.score;
  };
};

/**
  * Performs the immediate child Nodes of this in sequence. 
  */
class Sequence extends Node {
  constructor() {
    super();
  }
  /**
    * Advances the cycle time by the duration of the Score, and advances the 
    * times in the Score to match. The interval of advancement can optionally 
    * be either the existing duration of the child Score, or the duration of 
    * the child Score multiplied by a scale factor, or the duration of the 
    * child Score rescaled to fit a predetermined duration. The interval of 
    * advancement may additionally be prefixed (positively) or postfixed 
    * (positively or negatively) by specific intervals. 
    */
  update_cycle_time(current_cycle_time, child_score) {
    const new_cycle_time = current_cycle_time + child_score.getDurationFromZero();
    for (let i = 0, n = child_score.size(); i < n; ++i) {
      let event = child_score.get(i);
      let current_time = event.getTime();
      let new_time = current_cycle_time + current_time;
      event.setTime(new_time);
      child_score.set(i, event);
    }
    return new_cycle_time;
  }
};
/**
  * Performs the immediate child Nodes of this simultaneously. The traversal 
  * times of the immediate child Nodes may differ from from each other,  
  * enabling the traversal times of those children to go out of phase and back 
  * into phase with the traversal times of this. Enables differential canons 
  * and other temporal structures, as well as contrapuntal sequences.
  */
class Stack extends Node {
  constructor() {
    super();
  }
};

/**
  * Repeatedly traverses the tree rooted in this Node, and renders the 
  * generated Score using Csound.
  */
class Cycle extends Node {
  constructor() {
    super();
    // This can be changed to define other systems of equal temperament.
    this.divisions_per_octave = 12;
    // Not to be confused with divisions per octave for equal temperament!
    this.conform_pitches = false;
    this.starting_time = 0;
    this.cycle_count = 0;
    // The number of times this Cycle will repeat; a negative value means 
    // loop indefinitely. The default is to loop indefinitely.
    // indefinitely.
    this.cycles = -1;
  }
  current_time() {
    return audioContext.currentTime;
  }
  performance_time() {
    return this.current_time() - this.starting_time;
  }
  start(csound) {
    cycler_log("[Cycle.start]");
    this.csound = csound;
    this.repeat = true;
    this.cycle_count = 0;
    this.starting_time = this.current_time();
    this.current_performance_time = this.performance_time();
    this.prior_performance_time = this.performance_time();
    this.expected_performance_time = this.performance_time();
    this.current_cycle_duration = 0;
    this.prior_cycle_duration = 0;
    this.begin_compute_time = 0;
    this.end_compute_time = 0;
    this.cycle();
    super.start();
  }
   stop() {
    cycler_log("[Cycle.stop]");
    this.repeat = false;
    super.stop();
  }
  /**
    * Sends Events generated by the current traversal to Csound for rendering.
    */
  render() {
    this.prior_performance_time = this.current_performance_time;
    this.prior_cycle_duration = this.current_cycle_duration;
    const score_text = this.score.getCsoundScore(this.divisions_per_octave, this.conform_pitches);
    // As close as possible to when Csound actually starts rendering _this_ cycle.
    this.current_performance_time = this.performance_time();
    this.csound.readScore(score_text);
    // As close as possible to when Csound should start rendering the _next_ cycle.
    this.current_cycle_duration = this.score.getDurationFromZero();
    this.expected_performance_time = this.prior_performance_time + this.current_cycle_duration;
    cycler_log("[Cycle.render] prior cycle duration: %12.6f current cycle duration: %12.6f", this.prior_cycle_duration, this.current_cycle_duration);
    cycler_log("[Cycle.render] prior rendering time: %12.6f current rendering time: %12.6f next rendering time: %12.6f", this.prior_performance_time, this.current_performance_time, this.expected_performance_time);
    cycler_log("[Cycle.render] score size:          %6d", this.score.size());
  }
  /**
    * Generates, transforms, and renders Events, until stopped.
    */
  cycle() {
    // Find the amount of time spent computing this traversal.
    this.begin_compute_time = this.performance_time();
    if (this.cycles !== -1) {
      if (this.cycle_count >= this.cycles) {
        this.stop();
        return;
      }
    }
    if (this.repeat === false) {
      this.stop();
      return;
    }
    this.cycle_count = this.cycle_count + 1;
    // A Cycle is always the root of its graph with respect to actual 
    // scheduling and rendering, starting at cycle 1, cycle time 0, and 
    // depth 1.
    this.score = this.traverse(0, 1);
    this.render();
    // Correct for timer drift, which is measured every cycle.
    let timer_drift;
    if (this.cycle_count > 1) {
      timer_drift = this.expected_performance_time - this.current_performance_time;
    } else {
      timer_drift = 0;
    }
    let timer_interval = this.current_cycle_duration;
    // The correction applies the drift in reverse.
    timer_interval = Math.max(0, timer_interval - timer_drift);
    // Also correct for compute time.
    this.end_compute_time = this.performance_time();
    const compute_duration = this.end_compute_time - this.begin_compute_time;
    timer_interval = Math.max(0, timer_interval - compute_duration);
    cycler_log("[Cycle.cycle] count: %5d cycle duration: %12.6f compute time: %12.6f timer drift: %12.6f timer interval:%9.4f", this.cycle_count, this.current_cycle_duration, compute_duration, timer_drift, timer_interval);
    let that = this;
    let closure = function () {
      that.cycle();
    };      
    // Repeat the cycle...
    setTimeout(closure, 1000. * timer_interval);  
  };    
}

/**
  * Compositions are written by defining Nodes that generate and/or transform 
  * Events (usually notes), and adding these Nodes first to `Player.root`, and 
  * then to children of `root`, and so on recursively. All compositions must 
  * contain an instance of Cycle (the only Node that actually sends Events to 
  * Csound); by default, the root Node of this is a Cycle.
  */
class Player {
/**
  * The constructor takes a defined instance of Csound that has already 
  * compiled its orchestra and is already performing.
  */
  constructor(csound) {
    this.csound = csound;
    // The default root Node is an instance of Cycle; the composer may change that.
    // By default, this Cycle loops indefinitely.
    this.root = new Cycle();
  };
  start() {
    cycler_log("[Player.start]");
    this.root.start(this.csound);
  }
  stop() {
    cycler_log("[Player.stop]");
    this.root.stop();
  }
};






