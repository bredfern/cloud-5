/**
  * This file implements real-time and/or "always-on" score generation for 
  * cloud-music. 
  * 
  * Author: Michael Gogins
  * Copyright: 2023.
  * Licence: GNU Lesser General Public License, version 2.1.
  *
  * Algorithm
  * ---------
  *
  * This algorithm is _very_ loosely inspired by Tidal Cycles. This algorithm 
  * is concerned only with generating and processing Events; these are 
  * numerical vectors that correspond directly to Csound "i" statements, 
  * usually notes. (Control signals are generated either within Csound 
  * instruments, or as JavaScript calls to `Csound.setChannelValue`.) 
  *
  * Another difference is that Tidal Cycles resolves every note to its own 
  * node in the graph to be performed; whereas here, any node, even leaf 
  * nodes, may contain processes or scores that produce multiple notes.
  */
  
var AudioContext = window.AudioContext || window.webkitAudioContext;
var audioContext = new AudioContext();
var cycler_logging_enabled = true;
  
async function cycler_log() {
  if (cycler_logging_enabled === true) {
    const current_time = audioContext.currentTime;
    const formatted = sprintf(...arguments);
    const text = sprintf("[cycler][%9.4f] %s", current_time, formatted);
    console.log(text);
  }
}

/**
  * Base class for all Nodes.
  */
class Node {
  constructor() {
    this.children = new Array();
    /**
      * The Score will contain all Events generated by all children and this, 
      * in addition to Events generated by this.
      */
    this.score = new CsoundAC.Score();
    /**
      * The times of all child Events of this are rescaled by this factor.
      * The default is not to rescale.
      */
    this.time_scale = 1;
    /**
      * If the duration is not zero, all child Events of this are rescaled 
      * to fit the duration. The default is not to rescale.
      */
    this.time_duration = 0;
    /**
      * If the offset is not zero, the value of the offset in seconds is added 
      * to the time of each Event.
      */
    this.time_offset = 0;
  };
  /**
    * Adds the child Node to the list of immediate children of this.
    */
  add_child(child) {
    this.children.push(child);
  }
  /**
    * Called by the Player recursively to begin the performance. The default 
    * implementation does nothing but recursively call this method.
    */
  start(csound) {
    for (let child of this.children) {
      child.start(csound);
    }
  }
  /**
    * Called by the Player recursively to stop the performance. The default 
    * implementation does nothing but recursively call this method.
    */
  stop() {
    for (let child of this.children) {
      child.stop();
    }
  }
  /**
    * Optionally generates Events and pushes them onto the Score. The 
    * times of the Events are assumed to start at 0 and their durations are 
    * set by code, but the Score times may later be rescaled and/or offset.
    * The default implementation does nothing.
    */
  generate(score) {
  };
  /**
    * Optionally transforms some or all Events in the Score. The default 
    * implementation does nothing.
    */
  transform(score) {
  };
  /**
    * Optionally rescales and/or offsets the Score times. Returns the duration 
    * in seconds of the resulting score. This method takes into account the 
    * offset, but not the cycle time.
    */
  rescale_score(score) {
    cycler_log("[Node][rescale_score]...");
    let original_duration = score.getDurationFromZero();
    let rescaled_duration;
    if (this.time_duration > 0) {
      score.setDurationFromZero(this.time_duration);
    } else if (this.time_scale !== 1) {
      rescaled_duration = original_duration * ratio;
      score.setDurationFromZero(rescaled_duration);
    } 
    if (this.time_offset !== 0) {
      for (let i = 0, n = score.size(); i < n; ++i) {
        let event = score.get(i);
        let current_time = event.getTime();
        let new_time = offset + current_time;
        event.setTime(new_time);
        score.set(i, event);
      }
    }
    rescaled_duration = score.getDurationFromZero();
    cycler_log("[Node][rescale_score] original duration: %9.4f rescaled duration: %9.4f", original_duration, rescaled_duration);
    return rescaled_duration;
  }
  /**
    * Updates the cycle time from the child. The default implementation simply 
    * resets the cycle time.
    */
  update_cycle_time(cycle_time, child_score) {
    return 0;
  }
  /**
    * Recursively calls traverse, generate, and transform, advancing the cycle  
    * time as required. At the root node, the cycle time always starts at 0; 
    * the cycle time is thus recursively updated as the tree is traversed.
    */
  traverse(cycle_time, depth, parent_score) {
    cycler_log("%s[Node.traverse] cycle_start: %9.4f depth: %5d events: %6d", '  '.repeat(depth), cycle_time, depth, parent_score.size());
    // Clear the score of all child Events.
    this.score.clear();
    for (let child of this.children) {
      // Accumulate Events from child Nodes.
      child.traverse(cycle_time, depth + 1, this.score);
      // Optionally, rescale the child Score.
      child.rescale_score(child.score);
      // Optionally leave unchanged, advance, or reset the cycle time.
      cycle_time = this.update_cycle_time(cycle_time, child.score);
      // Transfer all Events from the child Score to this Score.
      for (let i = 0, n = child.score.size(); i < n; ++i) {
        let event = child.score.get(i);
        this.score.append_event(event);
      }
    };
    // Optionally, generate own Events and push on the Score.
    this.generate(this.score);
    // Optionally, transform all Events in the Score.
    this.transform(this.score);
    // Transfer all Events from this Score to the parent Score.
    for (let i = 0, n = this.score.size(); i < n; ++i) {
      let event = this.score.get(i);
      parent_score.append_event(event);
    }
  };
};

/**
  * Performs the immediate child Nodes of this in sequence. The duration of 
  * this is the sum of the durations of its _immediate_ children. 
  */
class Sequence extends Node {
  constructor() {
    super();
  }
  /**
    * Advances the cycle time by the duration of the Score.
    */
  update_cycle_time(cycle_time, child_score) {
    cycle_time += super.update_cycle_time(cycle_time, score);
    return cycle_time;
  }
};
/**
  * Performs the immediate child Nodes of this simultaneously. The traversal 
  * times of the immediate child Nodes may differ from from each other,  
  * enabling the traversal times of those children to go out of phase and back 
  * into phase with the traversal times of this. Enables differential canons 
  * and other temporal structures, as well as contrapuntal sequences.
  */
class Stack extends Node {
  constructor() {
    super();
  }
};

/**
  * Repeatedly traverses the tree rooted in this Node, and renders the 
  * generated Score using Csound.
  */
class Cycle extends Node {
  constructor() {
    super();
    // This can be changed to define other systems of equal temperament.
    this.divisions_per_octave = 12;
    // Not to be confused with divisions per octave for equal temperament!
    this.conform_pitches = false;
    this.starting_time = 0;
    this.cycle_count = 0;
  }
  current_time() {
    return audioContext.currentTime;
  }
  performance_time() {
    return this.current_time() - this.starting_time;
  }
  start(csound) {
    cycler_log("[Cycle] start...");
    this.csound = csound;
    this.repeat = true;
    this.cycle_count = 0;
    this.starting_time = this.current_time();
    this.current_performance_time = this.performance_time();
    this.prior_performance_time = this.performance_time();
    this.expected_performance_time = this.performance_time();
    this.current_cycle_duration = 0;
    this.prior_cycle_duration = 0;
    this.begin_compute_time = 0;
    this.end_compute_time = 0;
    this.prior_cycle_onset = 0;
    this.actual_cycle_onset = 0;
    this.expected_cycle_onset = 0;
    this.cycle();
    super.start();
  }
  stop() {
    cycler_log("[Cycle] stop...");
    this.repeat = false;
    super.stop();
  }
  /**
    * Sends Events generated by the current traversal to Csound for rendering.
    */
  render() {
    this.prior_performance_time = this.current_performance_time;
    this.prior_cycle_duration = this.current_cycle_duration;
    const score_text = this.score.getCsoundScore(this.divisions_per_octave, this.conform_pitches);
    // As close as possible to when Csound actually starts rendering this Score.
    this.current_performance_time = this.performance_time();
    this.csound.readScore(score_text);
    // As close as possible to when Csound should start rendering the next cycle.
    this.current_cycle_duration = this.score.getDurationFromZero();
    this.expected_performance_time = this.prior_performance_time + this.current_cycle_duration;
    cycler_log("[Cycle.render] prior rendering time: %9.4f current rendering time: %9.4f next rendering time: %9.4f", this.prior_performance_time, this.current_performance_time, this.expected_performance_time);
    cycler_log("[Cycle.render] prior cycle duration: %9.4f current cycle duration: %9.4f", this.prior_cycle_duration, this.current_cycle_duration);
    console.log(score_text);
  }
  /**
    * Generates, transforms, and renders Events, until stopped.
    */
  cycle() {
    // Find the amount of time spent computing this traversal.
    if (this.repeat === false) {
      return;
    }
    this.begin_compute_time = this.performance_time();
    this.expected_cycle_onset = this.prior_cycle_onset + this.prior_cycle_duration;
    this.prior_cycle_onset = this.actual_cycle_onset;
    this.actual_cycle_onset = this.begin_compute_time;
    this.score.clear();
    // Reset the cycle time to 0, and traverse the graph one time.
    this.traverse(0, this.cycle_count, this.score);
    this.render();
    this.cycle_count = this.cycle_count + 1;
    cycler_log("[Cycle.cycle] cycle count: %9d", this.cycle_count);
    // Correct for timer drift, which is measured every cycle.
    const timer_drift = this.actual_cycle_onset - this.expected_cycle_onset;
    // The correction applies the drift in reverse.
    let timer_interval = Math.max(0, this.current_cycle_duration - timer_drift);
    // Also correct for compute time.
    this.end_compute_time = this.performance_time();
    const compute_duration = this.end_compute_time - this.begin_compute_time;
    timer_interval = Math.max(0, timer_interval - compute_duration);
    cycler_log("[Cycle.cycle] cycle duration: %9.4f compute time: %9.4f timer drift: %9.4f timer interval:%9.4f", this.current_cycle_duration, compute_duration, timer_drift, timer_interval);
    let that = this;
    let closure = function () {
      that.cycle();
    };      
    // Repeat the cycle...
    setTimeout(closure, timer_interval * 1000.);  
  };    
}

/**
  * Compositions are written by defining Nodes that generate and/or transform 
  * Events (usually notes), and adding these Nodes first to `Player.root`, and 
  * then to children of `root`, and so on recursively. All compositions must 
  * contain an instance of Cycle (the only Node that actually sends Events to 
  * Csound); by default, the root Node of this is a Cycle.
  */
class Player {
/**
  * The constructor takes a defined instance of Csound that has already 
  * compiled its orchestra and is already performing.
  */
  constructor(csound) {
    this.csound = csound;
    // The default root Node is an instance of Cycle; the composer may change that.
    this.root = new Cycle();
  };
  start() {
    cycler_log("[Player] starting...");
    this.root.start(this.csound);
  }
  stop() {
    cycler_log("[Player] stopping...");
    this.root.stop();
  }
};






